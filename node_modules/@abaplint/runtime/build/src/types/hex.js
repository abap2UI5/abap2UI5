"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hex = void 0;
const _parse_1 = require("../operators/_parse");
const float_1 = require("./float");
const xstring_1 = require("./xstring");
const throw_error_1 = require("../throw_error");
const integer8_1 = require("./integer8");
const REGEXP = /^(?![A-F0-9])/;
class Hex {
    constructor(input) {
        this.length = input?.length ? input?.length : 1;
        this.qualifiedName = input?.qualifiedName;
        this.clear();
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        const doubleLength = this.length * 2;
        if (typeof value === "string") {
            this.value = value;
        }
        else if (typeof value === "number") {
            const maxVal = Math.pow(2, this.length * 8);
            if (value < 0) {
                let hex = Math.round(value + 0x100000000).toString(16).toUpperCase();
                if (hex.length > doubleLength) {
                    hex = hex.substring(hex.length - doubleLength);
                }
                this.value = hex;
            }
            else if (value >= maxVal) {
                const sub = value % maxVal;
                this.value = Math.round(sub).toString(16).toUpperCase();
            }
            else {
                this.value = Math.round(value).toString(16).toUpperCase();
            }
            this.value = this.value.padStart(doubleLength, "0");
        }
        else if (value instanceof integer8_1.Integer8) {
            let hex = "";
            if (value.get() < 0) {
                hex = (value.get() + 0x10000000000000000n).toString(16).toUpperCase();
                if (hex.length > doubleLength) {
                    hex = hex.substring(hex.length - doubleLength);
                }
            }
            else {
                hex = value.get().toString(16).toUpperCase();
                hex = hex.padStart(doubleLength, "0");
            }
            return this.set(hex);
        }
        else if (value instanceof Hex || value instanceof xstring_1.XString) {
            this.value = value.get();
        }
        else {
            const v = value.get();
            if (value instanceof float_1.Float) {
                return this.set(value.getRaw());
            }
            else if (typeof v === "number") {
                return this.set(v);
            }
            else {
                this.value = v;
                if (this.value.match(REGEXP)) {
                    this.value = "";
                }
            }
        }
        if (this.value.length > doubleLength) {
            this.value = this.value.substr(0, doubleLength);
        }
        else if (this.value.length < doubleLength) {
            this.value = this.value.padEnd(doubleLength, "0");
        }
        //    this.value = this.value.toUpperCase(); // todo, for some reason abapNTLM needs this? investigate
        return this;
    }
    getLength() {
        return this.length;
    }
    clear() {
        this.value = "0".repeat(this.length * 2);
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            if (offset instanceof integer8_1.Integer8) {
                offset = Number(offset.get());
            }
            else {
                offset = (0, _parse_1.parse)(offset);
            }
            if (offset * 2 > this.value.length
                || offset < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        let length = input?.length;
        if (length) {
            if (length instanceof integer8_1.Integer8) {
                length = Number(length.get());
            }
            else {
                length = (0, _parse_1.parse)(length);
            }
            if (length * 2 > this.value.length
                || length < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        // NOTE: this only copies the minimal length of the string,
        if (offset !== undefined && length !== undefined) {
            if (offset * 2 + length * 2 > this.value.length) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
            return new xstring_1.XString().set(this.value.substr(offset * 2, length * 2));
        }
        else if (offset !== undefined) {
            return new xstring_1.XString().set(this.value.substr(offset * 2));
        }
        else if (length !== undefined) {
            return new xstring_1.XString().set(this.value.substr(0, length * 2));
        }
        else {
            throw new Error("hex: getOffset, unexpected");
        }
    }
}
exports.Hex = Hex;
//# sourceMappingURL=hex.js.map