"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldSymbol = void 0;
const table_1 = require("./table");
const string_1 = require("./string");
const hex_1 = require("./hex");
const float_1 = require("./float");
const data_reference_1 = require("./data_reference");
const hex_uint8_1 = require("./hex_uint8");
class FieldSymbol {
    constructor(type) {
        this.pointer = undefined;
        this.casting = false;
        this.type = type;
    }
    getQualifiedName() {
        // @ts-ignore
        return this.type.getQualifiedName();
    }
    assign(pointer) {
        this.pointer = pointer;
    }
    setCasting() {
        this.casting = true;
    }
    unassign() {
        this.pointer = undefined;
    }
    isAssigned() {
        return this.pointer !== undefined;
    }
    getPointer() {
        if (this.casting) {
            // todo, this wont work for everything, eg changing CASTING'ed values
            return this.get();
        }
        return this.pointer;
    }
    dereference() {
        if (this.pointer instanceof data_reference_1.DataReference) {
            return this.pointer.getPointer();
        }
        else {
            return this.pointer;
        }
    }
    ///////////////
    clear() {
        return this.pointer?.clear();
    }
    get() {
        if (this.casting) {
            if (this.type instanceof hex_1.Hex || this.type instanceof hex_uint8_1.HexUInt8) {
                const pt = this.pointer;
                if (pt instanceof float_1.Float) {
                    const buf = Buffer.allocUnsafe(8);
                    // CASTING is platform specific, so perhaps add a setting? But anyhow its not something developers should use
                    buf.writeDoubleLE(pt.getRaw());
                    return buf.toString("hex").toUpperCase();
                }
                else {
                    // @ts-ignore
                    const ret = new string_1.String().set(Buffer.from(this.pointer?.get(), "utf16le").toString("hex"));
                    return ret.get();
                }
            }
            else {
                // @ts-ignore
                const ret = new string_1.String().set(Buffer.from(this.pointer?.get(), "hex").toString("utf16le"));
                return ret.get();
            }
        }
        else {
            // @ts-ignore
            return this.pointer?.get();
        }
    }
    appendInitial() {
        if (this.pointer instanceof table_1.Table) {
            return this.pointer.appendInitial();
        }
        return undefined;
    }
    array() {
        // @ts-ignore
        return this.pointer?.array();
    }
    getArrayLength() {
        // @ts-ignore
        return this.pointer?.getArrayLength();
    }
    set(value) {
        if (this.casting) {
            if (this.type instanceof hex_1.Hex || this.type instanceof hex_uint8_1.HexUInt8) {
                const pt = this.pointer;
                if (pt instanceof float_1.Float) {
                    const buf = Buffer.from(value.get(), "hex");
                    pt.set(buf.readDoubleLE());
                    return;
                }
            }
        }
        this.pointer?.set(value);
        return this;
    }
    getOffset(input) {
        return this.getPointer().getOffset(input);
    }
}
exports.FieldSymbol = FieldSymbol;
//# sourceMappingURL=field_symbol.js.map