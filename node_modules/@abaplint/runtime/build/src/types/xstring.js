"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XString = void 0;
const _parse_1 = require("../operators/_parse");
const float_1 = require("./float");
const character_1 = require("./character");
const throw_error_1 = require("../throw_error");
const integer8_1 = require("./integer8");
class XString {
    constructor(input) {
        this.value = "";
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "string") {
            this.value = value;
            if (this.value.length % 2 === 1) {
                this.value = this.value + "0";
            }
        }
        else if (typeof value === "number") {
            this.value = Math.round(value).toString(16).toUpperCase();
            if (this.value.length % 2 === 1) {
                this.value = "0" + this.value;
            }
        }
        else {
            let v = value.get();
            if (value instanceof float_1.Float) {
                v = value.getRaw();
                this.set(v);
            }
            else if (value instanceof character_1.Character) {
                this.set(value.getTrimEnd());
            }
            else if (typeof v === "number") {
                this.value = v.toString(16).toUpperCase();
                if (this.value.length % 2 === 1) {
                    this.value = "0" + this.value;
                }
            }
            else {
                this.set(v);
            }
        }
        return this;
    }
    clear() {
        this.value = "";
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            if (offset instanceof integer8_1.Integer8) {
                offset = Number(offset.get());
            }
            else {
                offset = (0, _parse_1.parse)(offset);
            }
            if (offset * 2 > this.value.length
                || offset < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        let length = input?.length;
        if (length) {
            if (length instanceof integer8_1.Integer8) {
                length = Number(length.get());
            }
            else {
                length = (0, _parse_1.parse)(length);
            }
            if (length * 2 > this.value.length
                || length < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        // NOTE: this only copies the minimal length of the string,
        if (offset !== undefined && length !== undefined) {
            if (offset * 2 + length * 2 > this.value.length) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
            return new XString().set(this.value.substr(offset * 2, length * 2));
        }
        else if (offset !== undefined) {
            return new XString().set(this.value.substr(offset * 2));
        }
        else if (length !== undefined) {
            return new XString().set(this.value.substr(0, length * 2));
        }
        else {
            throw new Error("xstring: getOffset, unexpected");
        }
    }
}
exports.XString = XString;
//# sourceMappingURL=xstring.js.map