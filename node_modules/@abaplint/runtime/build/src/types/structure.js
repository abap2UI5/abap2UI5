"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Structure = void 0;
const clone_1 = require("../clone");
const field_symbol_1 = require("./field_symbol");
const table_1 = require("./table");
const _parse_1 = require("../operators/_parse");
const character_1 = require("./character");
const throw_error_1 = require("../throw_error");
class Structure {
    constructor(fields, qualifiedName, ddicName, suffix, asInclude) {
        this.value = fields;
        this.qualifiedName = qualifiedName?.toUpperCase();
        this.ddicName = ddicName?.toUpperCase();
        this.suffix = suffix;
        this.asInclude = asInclude;
    }
    clear() {
        for (const f in this.value) {
            // @ts-ignore
            this.value[f].clear();
        }
        return this;
    }
    getDDICName() {
        return this.ddicName;
    }
    getRenamingSuffix() {
        return this.suffix;
    }
    getAsInclude() {
        return this.asInclude;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(input) {
        if (input === undefined) {
            return;
        }
        if (input instanceof field_symbol_1.FieldSymbol) {
            this.set(input.getPointer());
        }
        else if (input instanceof table_1.Table) {
            throw new Error("Structure, input is a table");
        }
        else if (input instanceof Structure) {
            const obj = input.get();
            const keys1 = Object.keys(obj);
            const keys2 = Object.keys(this.value);
            /*
            console.dir(keys1);
            console.dir(keys2);
      */
            for (let i = 0; i < keys1.length; i++) {
                const key1 = keys1[i];
                const key2 = keys2[i];
                this.value[key2].set((0, clone_1.clone)(obj[key1]));
            }
            /*
                  for (const f in obj) {
                    // @ts-ignore
                    this.value[f].set(clone(obj[f]));
                  }
                  */
        }
        else {
            this.setCharacter(input);
        }
        return this;
    }
    setCharacter(input) {
        this.clear();
        let val = input;
        if (typeof val !== "string") {
            val = val.get() + "";
        }
        for (const key of Object.keys(this.value)) {
            const targetLength = this.value[key].getLength();
            this.value[key].set(val.substr(0, targetLength));
            val = val.substr(targetLength);
        }
    }
    get() {
        return this.value;
    }
    getCharacter() {
        let val = "";
        for (const v in this.value) {
            if (this.value[v] instanceof Structure) {
                val += this.value[v].getCharacter();
            }
            else {
                val += this.value[v].get();
            }
        }
        return val;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            offset = (0, _parse_1.parse)(offset);
        }
        let length = input?.length;
        if (length) {
            length = (0, _parse_1.parse)(length);
        }
        const val = this.getCharacter();
        if ((offset && offset >= val.length)
            || (offset && offset < 0)
            || (length && length < 0)) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        let ret = val;
        if (offset) {
            ret = ret.substr(offset);
        }
        if (length !== undefined) {
            ret = ret.substr(0, length);
        }
        const r = new character_1.Character(ret.length);
        r.set(ret);
        return r;
    }
}
exports.Structure = Structure;
//# sourceMappingURL=structure.js.map