"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replace = replace;
const abap_regex_1 = require("../abap_regex");
const types_1 = require("../types");
const concatenate_1 = require("./concatenate");
function replace(input) {
    if (input.target instanceof types_1.Table) {
        for (const row of input.target.array()) {
            replace({ ...input, target: row });
        }
        return;
    }
    let temp = input.target.get();
    const ignoreCase = input.ignoringCase === true ? "i" : "";
    const allOccurrences = input.all === true ? "g" : "";
    let search = undefined;
    let found = false;
    if (input.of) {
        let inp = input.of.get();
        if (input.of instanceof types_1.Character) {
            inp = input.of.getTrimEnd();
        }
        if (inp.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        found = temp.indexOf(inp) >= 0;
        inp = abap_regex_1.ABAPRegExp.escapeRegExp(inp);
        search = new RegExp(inp, ignoreCase + allOccurrences);
    }
    else if (input.regex) {
        // TODO: this is a bit wrong, ABAP regex is not like JS regex
        const regex = abap_regex_1.ABAPRegExp.convert(input.regex.get());
        if (regex.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        search = new RegExp(regex, ignoreCase + allOccurrences);
        found = temp.match(search) !== null;
    }
    else if (input.pcre) {
        const str = input.pcre.get();
        const regex = abap_regex_1.ABAPRegExp.convert(str);
        if (regex.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        search = new RegExp(regex, ignoreCase + allOccurrences);
        found = temp.match(search) !== null;
    }
    else if (input.sectionLength && input.sectionOffset) {
        const before = input.target.getOffset({ length: input.sectionOffset });
        const after = input.target.getOffset({ offset: input.sectionLength.get() + input.sectionOffset.get() });
        (0, concatenate_1.concatenate)({ source: [before, input.with, after], target: input.target });
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(0);
        return;
    }
    else {
        throw "REPLACE, unexpected input";
    }
    let rr = "";
    if (typeof input.with === "string") {
        rr = input.with;
    }
    else {
        if (input.with instanceof types_1.Character) {
            rr = input.with.getTrimEnd();
        }
        else {
            rr = input.with.get();
        }
        rr = rr.replace(/\\\$/g, "$");
        rr = rr.replace(/\\\{/g, "{");
        rr = rr.replace(/\\\}/g, "}");
    }
    if (input.replacementLength) {
        const match = temp.match(search);
        let replacement = rr;
        for (let counter = 1; counter < 10; counter++) {
            const dollar = "$" + counter;
            if (replacement.includes(dollar) && match && match[counter] !== undefined) {
                replacement = replacement.replace(dollar, match[counter]);
            }
        }
        input.replacementLength.set(replacement.length);
    }
    if (input.replacementCount) {
        const match = temp.match(search);
        input.replacementCount.set(match?.length || 0);
    }
    temp = temp.replace(search, rr);
    const subrc = found ? 0 : 4;
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    input.target.set(temp);
}
//# sourceMappingURL=replace.js.map