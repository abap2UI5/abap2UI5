"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shift = shift;
const compare_1 = require("../compare");
const types_1 = require("../types");
function shift(target, options) {
    if (options?.mode === "BYTE") {
        shift_byte_mode(target, options);
    }
    else {
        shift_character_mode(target, options);
    }
}
function shift_character_mode(target, options) {
    let value = target.get();
    if (options?.deletingLeading) {
        let leading = options.deletingLeading;
        if (typeof leading !== "string") {
            leading = leading.get();
        }
        const split = leading.split("");
        while (split.some(s => value.substr(0, 1) === s)) {
            value = value.substr(1);
        }
    }
    else if (options?.deletingTrailing) {
        let trailing = options.deletingTrailing;
        if (typeof trailing !== "string") {
            trailing = trailing.get();
        }
        if ((0, compare_1.co)(value, " ") === false) {
            while (value.endsWith(trailing)) {
                value = " ".repeat(trailing.length) + value.substring(0, value.length - trailing.length);
            }
        }
    }
    else if (options?.places) {
        const p = options.places.get();
        if (options.circular) {
            value = value.substr(p) + value.substr(0, p);
        }
        else {
            if (options.direction === "RIGHT") {
                value = " ".repeat(options.places.get()) + value.substring(0, options.places.get());
            }
            else {
                value = value.substr(p);
            }
        }
    }
    else if (options?.to) {
        let to = "";
        if (typeof options.to === "string") {
            to = options.to;
        }
        else {
            to = options.to.get();
        }
        const index = value.search(to);
        if (index > 0) {
            value = value.substr(index);
        }
    }
    else if (options?.circular) {
        if (options.direction === "RIGHT") {
            value = value.substring(value.length - 1, value.length) + value.substring(0, value.length - 1);
        }
        else {
            value = value.substr(1) + value.substr(0, 1);
        }
    }
    else {
        value = value.substr(1);
    }
    if (target instanceof types_1.Numc) {
        target.set(value, true);
    }
    else {
        target.set(value);
    }
}
function shift_byte_mode(target, options) {
    let value = target.get();
    if (options?.deletingLeading) {
        let leading = options.deletingLeading;
        if (typeof leading !== "string") {
            leading = leading.get();
        }
        const split = leading.split("");
        while (split.some(s => value.substr(0, 2) === s)) {
            value = value.substr(2);
        }
    }
    else if (options?.places) {
        if (options.circular) {
            if (options.direction === "RIGHT") {
                for (let i = 0; i < options.places.get(); i++) {
                    value = value.substr(value.length - 2) + value.substr(0, value.length - 2);
                }
            }
            else {
                for (let i = 0; i < options.places.get(); i++) {
                    value = value.substr(2) + value.substr(0, 2);
                }
            }
        }
        else {
            const p = options.places.get() * 2;
            if (options.direction === "RIGHT") {
                value = "0".repeat(p) + value.substring(0, p);
            }
            else {
                value = value.substr(p);
            }
        }
    }
    else if (options?.to) {
        let to = "";
        if (typeof options.to === "string") {
            to = options.to;
        }
        else {
            to = options.to.get();
        }
        const index = value.search(to);
        if (index > 0) {
            value = value.substr(index);
        }
    }
    else if (options?.circular) {
        value = value.substr(2) + value.substr(0, 2);
    }
    else {
        value = value.substr(2);
    }
    target.set(value);
}
//# sourceMappingURL=shift.js.map