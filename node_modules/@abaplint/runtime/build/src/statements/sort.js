"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sort = sort;
const types_1 = require("../types");
const compare_1 = require("../compare");
function compare(a, b, input) {
    const componentName = input.component;
    const descending = input.descending;
    let vala = undefined;
    let valb = undefined;
    if (componentName === "table_line") {
        vala = a.get();
        valb = b.get();
    }
    else if (componentName.includes("-")) {
        const sub = componentName.split("-");
        vala = a;
        valb = b;
        for (const s of sub) {
            vala = vala.get()[s];
            valb = valb.get()[s];
        }
    }
    else {
        vala = a.get()[componentName];
        valb = b.get()[componentName];
    }
    if (vala === undefined || valb === undefined) {
        throw new Error("sort compare, wrong component name, " + componentName);
    }
    if (descending && (0, compare_1.gt)(vala, valb)) {
        return -1;
    }
    else if (!descending && (0, compare_1.lt)(vala, valb)) {
        return -1;
    }
    else if ((0, compare_1.eq)(vala, valb)) {
        return 0;
    }
    else {
        return 1;
    }
}
function sort(input, options) {
    //  console.dir(input);
    if (input instanceof types_1.FieldSymbol) {
        const pnt = input.getPointer();
        if (pnt === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        sort(pnt, options);
        return;
    }
    else if (options?.skipSortedCheck !== true
        && input instanceof types_1.Table
        && input.getOptions()?.primaryKey?.type === types_1.TableAccessType.sorted) {
        throw new Error("SORT called on sorted table");
    }
    if (input instanceof types_1.HashedTable) {
        throw new Error("Sort hashed table, ugh?");
    }
    if (options?.by) {
        if (options.by.length === 0) {
            throw "SortByLengthZero";
        }
        input.sort((a, b) => {
            for (const c of options.by || []) {
                const res = compare(a, b, c);
                if (res !== 0) {
                    return res;
                }
            }
            return 0;
        });
    }
    else {
        const descending = options?.descending === true;
        input.sort((a, b) => {
            if ((0, compare_1.eq)(a, b)) {
                return 0;
            }
            else if (descending && (0, compare_1.gt)(a, b)) {
                return -1;
            }
            else if (!descending && (0, compare_1.lt)(a, b)) {
                return -1;
            }
            else {
                return 1;
            }
        });
    }
}
//# sourceMappingURL=sort.js.map