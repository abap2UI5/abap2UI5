"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertInternal = insertInternal;
const clone_1 = require("../clone");
const compare_1 = require("../compare");
const types_1 = require("../types");
const read_table_1 = require("./read_table");
const sort_1 = require("./sort");
function insertInternal(options) {
    if (options.table instanceof types_1.FieldSymbol) {
        if (options.table.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        options.table = options.table.getPointer();
    }
    else if (options.data instanceof types_1.FieldSymbol) {
        if (options.data.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        options.data = options.data.getPointer();
    }
    const tableOptions = options.table.getOptions();
    let isSorted = tableOptions?.primaryKey?.type === types_1.TableAccessType.sorted
        || tableOptions?.primaryKey?.type === types_1.TableAccessType.hashed;
    if (options.table instanceof types_1.HashedTable) {
        isSorted = false;
    }
    else if (isSorted) {
        const insert = options.data instanceof types_1.Structure ? options.data.get() : { table_line: options.data };
        let compare = (row) => {
            for (const key of tableOptions?.primaryKey?.keyFields || []) {
                if (key.includes("-")) {
                    const [first, second] = key.split("-");
                    if ((0, compare_1.ne)(row[first.toLowerCase()].get()[second.toLowerCase()], insert[first.toLowerCase()].get()[second.toLowerCase()])) {
                        return false;
                    }
                }
                else {
                    if ((0, compare_1.ne)(row[key.toLowerCase()], insert[key.toLowerCase()])) {
                        return false;
                    }
                }
            }
            return true;
        };
        if (tableOptions.primaryKey?.isUnique === true) {
            const withKeyValue = [];
            let binary = false;
            const data = options?.data;
            if (data instanceof types_1.Structure) {
                const fieldName = tableOptions.primaryKey.keyFields[0].toLowerCase();
                if (fieldName !== "table_line" && fieldName.includes("-") === false) {
                    withKeyValue.push({ key: (i) => { return i[fieldName]; }, value: data.get()[fieldName] });
                    binary = true;
                }
            }
            else {
                compare = (row) => {
                    // @ts-ignore
                    return (0, compare_1.eq)(row.table_line, options.data);
                };
            }
            (0, read_table_1.readTable)(options.table, { withKey: compare, withKeyValue: withKeyValue, binarySearch: binary });
            // @ts-ignore
            if (abap.builtin.sy.get().subrc.get() === 0) {
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(4);
                return;
            }
        }
    }
    let data = options.data;
    if (typeof data === "string") {
        const tmp = (0, clone_1.clone)(options.table.getRowType());
        tmp.set(data);
        data = tmp;
    }
    if (data && options.index) {
        const index = options.index.get() - 1;
        const val = options.table.insertIndex(data, index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
    }
    else if (options.lines
        && (options.data instanceof types_1.Table
            || options.data instanceof types_1.HashedTable)) {
        if (options.table instanceof types_1.HashedTable) {
            for (const source of options.data.array()) {
                const result = options.table.insert(source);
                if (result.subrc !== 0) {
                    throw new Error("ITAB_DUPLICATE_KEY");
                }
            }
        }
        else {
            for (const i of options.data.array()) {
                options.table.append(i);
            }
        }
    }
    else if (options.initial === true) {
        let index = options.table.getArrayLength();
        if (options.index) {
            index = options.index.get() - 1;
        }
        const val = options.table.insertIndex(options.table.getRowType(), index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
    }
    else if (options.table instanceof types_1.HashedTable && data) {
        const { value: val, subrc: subrc } = options.table.insert(data);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(subrc);
        return;
    }
    else if (data) {
        // todo, for now it just appends, this is not correct, but currently the table type is not known
        const val = options.table.insertIndex(data, options.table.getArrayLength(), options.noClone);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
    if (isSorted && !(options.table instanceof types_1.HashedTable)) {
        // slow, but works for now
        let by = tableOptions?.primaryKey?.keyFields?.map(f => {
            return { component: f.toLowerCase() };
        });
        if (by?.length === 1 && by[0].component === "table_line") {
            by = [];
        }
        if (by && by.length > 0) {
            (0, sort_1.sort)(options.table, { by: by, skipSortedCheck: true });
        }
        else {
            (0, sort_1.sort)(options.table, { skipSortedCheck: true });
        }
    }
}
//# sourceMappingURL=insert_internal.js.map