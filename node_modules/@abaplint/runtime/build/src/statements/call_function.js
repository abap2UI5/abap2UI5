"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallFunction = void 0;
const throw_error_1 = require("../throw_error");
const types_1 = require("../types");
const receive_1 = require("./receive");
class CallFunction {
    constructor(context) {
        this.context = context;
    }
    // note: this is only called if DESTINIATION is supplied
    async callFunction(options) {
        const param = {
            exporting: options.exporting,
            importing: options.importing,
            tables: options.tables,
            changing: options.changing,
            exceptions: options.exceptions,
        };
        options.name = options.name.trimEnd();
        // @ts-ignore
        const fm = abap.FunctionModules[options.name];
        if (options.destination) {
            if (options.destination.trim() === "") {
                if (fm === undefined) {
                    (0, throw_error_1.throwError)("CX_SY_DYN_CALL_ILLEGAL_FUNC");
                }
                await fm(param);
                return;
            }
            const dest = this.context.RFCDestinations[options.destination];
            if (dest === undefined) {
                throw new Error(`RFC destination ${options.destination} does not exist`);
            }
            await dest.call(options.name, {
                exporting: options.exporting,
                importing: options.importing,
                tables: options.tables,
                changing: options.changing,
                exceptions: options.exceptions,
            });
        }
        else if (options.calling) {
            if (fm === undefined) {
                (0, throw_error_1.throwError)("CX_SY_DYN_CALL_ILLEGAL_FUNC");
            }
            await fm(param);
            // save importing + tables + changing + exception for RECEIVE RESULTS
            (0, receive_1._receiveSetResult)(param);
            // call the callback, async
            options.calling({ p_task: new types_1.Character(8).set("OPENABAP") });
        }
        else {
            throw new Error("runtime: callFunction, unexpected input");
        }
    }
}
exports.CallFunction = CallFunction;
//# sourceMappingURL=call_function.js.map