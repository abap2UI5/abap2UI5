"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initial = initial;
const types_1 = require("../types");
const REGEX_ZEROS = /^0+$/;
const REGEX_SPACES = /^ *$/;
function initial(val) {
    // todo, refactor? add as method in each type instead?
    if (val instanceof types_1.Table || val instanceof types_1.HashedTable) {
        return val.array().length === 0;
    }
    else if (val instanceof types_1.Integer8) {
        return val.get() === 0n;
    }
    else if (val instanceof types_1.DataReference) {
        return val.getPointer() === undefined;
    }
    else if (val instanceof types_1.Date) {
        return val.get() === "00000000";
    }
    else if (val instanceof types_1.Numc) {
        return val.get().match(REGEX_ZEROS) !== null;
    }
    else if (val instanceof types_1.Hex || val instanceof types_1.HexUInt8) {
        return val.get().match(REGEX_ZEROS) !== null;
    }
    else if (val instanceof types_1.Time) {
        return val.get() === "000000";
    }
    else if (val instanceof types_1.Float) {
        return val.getRaw() === 0;
    }
    else if (val instanceof types_1.Character) {
        return val.get().match(REGEX_SPACES) !== null;
    }
    else if (val instanceof types_1.FieldSymbol && val.getPointer() === undefined) {
        throw new Error("FS not assigned");
    }
    else if (val instanceof types_1.FieldSymbol) {
        const res = initial(val.getPointer());
        return res;
    }
    if (typeof val === "string") {
        return val === "";
    }
    else if (typeof val === "number") {
        return val === 0;
    }
    const value = val.get();
    if (typeof value === "string") {
        return value === "";
    }
    else if (typeof value === "number") {
        return value === 0;
    }
    else if (val instanceof types_1.ABAPObject) {
        return value === undefined;
    }
    else if (typeof value === "object") {
        for (const f of Object.keys(value)) {
            if (initial(value[f]) === false) {
                return false;
            }
        }
        return true;
    }
    else {
        throw new Error("runtime, initial, missing implementation");
    }
}
//# sourceMappingURL=initial.js.map