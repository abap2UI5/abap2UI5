"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eq = eq;
/* eslint-disable max-len */
const types_1 = require("../types");
const _parse_1 = require("../operators/_parse");
const initial_1 = require("./initial");
function compareTables(left, right) {
    const leftArray = left.array();
    const rightArray = right.array();
    if (leftArray.length !== rightArray.length) {
        return false;
    }
    for (let i = 0; i < leftArray.length; i++) {
        const rowCompare = eq(leftArray[i], rightArray[i]);
        if (rowCompare === false) {
            return false;
        }
    }
    return true;
}
function eq(left, right) {
    /*
      console.dir(left);
      console.dir(right);
    */
    if (right instanceof types_1.FieldSymbol) {
        return eq(left, right.getPointer());
    }
    else if (left instanceof types_1.FieldSymbol) {
        return eq(left.getPointer(), right);
    }
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        if (left instanceof types_1.Table || left instanceof types_1.HashedTable || right instanceof types_1.Table || right instanceof types_1.HashedTable) {
            // exception?
            return false;
        }
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return l === r;
    }
    // for performance, do the typicaly/easy cases first
    if (right instanceof types_1.Character) {
        if (left instanceof types_1.Character) {
            if (right.getLength() === left.getLength()) {
                return right.get() === left.get();
            }
            else {
                return right.getTrimEnd() === left.getTrimEnd();
            }
        }
        else if (left instanceof types_1.Integer) {
            return (0, types_1.toInteger)(right.get(), false) === left.get();
        }
        else if (left instanceof types_1.String
            || left instanceof types_1.XString
            || left instanceof types_1.Numc
            || left instanceof types_1.HexUInt8
            || left instanceof types_1.Hex) {
            return right.getTrimEnd() === left.get();
        }
    }
    else if (right instanceof types_1.String) {
        if (left instanceof types_1.Character) {
            return right.get() === left.getTrimEnd();
        }
        else if (left instanceof types_1.String) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Numc) {
        if (left instanceof types_1.Numc && right.getLength() === left.getLength()) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Integer) {
            return left.get() === parseInt(right.get(), 10);
        }
    }
    else if (right instanceof types_1.Integer) {
        if (left instanceof types_1.Integer || left instanceof types_1.Integer8) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Character) {
            return (parseInt(left.get(), 10) || 0) === right.get();
        }
        else if (left instanceof types_1.String) {
            return (parseInt(left.get(), 10) || 0) === right.get();
        }
        else if (left instanceof types_1.Float) {
            return right.get() === left.getRaw();
        }
        else if (left instanceof types_1.Numc) {
            return right.get() === parseInt(left.get(), 10);
        }
        else if (left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.DataReference && left instanceof types_1.DataReference) {
        return right.getPointer() === left.getPointer();
    }
    else if (right instanceof types_1.Table
        || right instanceof types_1.HashedTable) {
        if (left instanceof types_1.Table
            || left instanceof types_1.HashedTable) {
            return compareTables(left, right);
        }
        else {
            // this happens in dynamic/ANY typed scenarios?
            return false;
        }
    }
    else if (right instanceof types_1.Hex || right instanceof types_1.XString || right instanceof types_1.HexUInt8) {
        if (left instanceof types_1.Hex || left instanceof types_1.HexUInt8) {
            // @ts-ignore
            if (right.getLength && right.getLength() !== left.getLength()) {
                return (0, initial_1.initial)(left) && (0, initial_1.initial)(right);
            }
            return right.get() === left.get();
        }
        else if (left instanceof types_1.XString) {
            return right.get() === left.get();
        }
        /*
      } else if (right instanceof HexUInt8) {
        if (left instanceof XString) {
          return right.get() === left.get();
        } else if (left instanceof HexUInt8) {
    // https://stackoverflow.com/questions/21553528/how-to-test-for-equality-in-arraybuffer-dataview-and-typedarray
          const llen = left.getLength();
          if (llen === right.getLength()) {
    // todo: this can be optimized by creating multi byte views?
    //       new DataView(this.value.buffer).setInt32(0, 0, true);
            for (let i = 0; i < llen; i++) {
              if (right.getOffsetRaw(i) !== left.getOffsetRaw(i)) {
                return false;
              }
            }
          } else {
            return initial(left) && initial(right);
          }
        }
        */
    }
    else if (right instanceof types_1.ABAPObject) {
        if (left instanceof types_1.ABAPObject) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Date) {
        if (left instanceof types_1.Date) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Packed) {
        if (left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Integer) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Integer8) {
        if (left instanceof types_1.Integer
            || left instanceof types_1.Integer8
            || left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Float) {
            return right.get() === left.getRaw();
        }
    }
    else if (right instanceof types_1.Float) {
        if (left instanceof types_1.Float) {
            return right.getRaw() === left.getRaw();
        }
        else if (left instanceof types_1.Integer
            || left instanceof types_1.Integer8) {
            return right.getRaw() === left.get();
        }
    }
    if (left instanceof types_1.Structure || right instanceof types_1.Structure) {
        if (!(right instanceof types_1.Structure)) {
            return eq(left.getCharacter(), right);
        }
        else if (!(left instanceof types_1.Structure)) {
            return eq(left, right.getCharacter());
        }
        const l = left.get();
        const r = right.get();
        const leftKeys = Object.keys(l);
        const rightKeys = Object.keys(r);
        if (leftKeys.length !== rightKeys.length) {
            return false;
        }
        for (const k of leftKeys) {
            const e = eq(l[k], r[k]);
            if (e === false) {
                return false;
            }
        }
        return true;
    }
    let l = undefined;
    if (left instanceof types_1.Character) {
        l = left.getTrimEnd();
    }
    else if (left instanceof types_1.Date) {
        l = left.get().trimEnd();
    }
    else if (left instanceof types_1.Table || left instanceof types_1.HashedTable) {
        return false;
    }
    else if (typeof left === "object") {
        l = left.get();
    }
    else {
        l = left;
    }
    let r = undefined;
    if (right instanceof types_1.Character) {
        r = right.getTrimEnd();
    }
    else if (right instanceof types_1.Date) {
        r = right.get().trimEnd();
    }
    else if (typeof right === "object") {
        r = right.get();
    }
    else {
        r = right;
    }
    if ((right instanceof types_1.Hex || right instanceof types_1.HexUInt8) && typeof l === "number") {
        // todo, handle this case earlier
        r = parseInt(right.get(), 16);
    }
    else if ((left instanceof types_1.Hex || left instanceof types_1.HexUInt8) && typeof r === "number") {
        // todo, handle this case earlier
        l = parseInt(left.get(), 16);
    }
    if (right instanceof types_1.Float && left instanceof types_1.Float) {
        r = right.getRaw();
        l = left.getRaw();
    }
    else if (right instanceof types_1.Float && typeof l === "number") {
        r = right.getRaw();
    }
    else if (left instanceof types_1.Float) {
        if (typeof r === "number") {
            l = left.getRaw();
        }
        else if (typeof r === "string") {
            l = left.getRaw();
            r = Number(r);
        }
    }
    if (right instanceof types_1.Numc && left instanceof types_1.Integer) {
        l = left.get();
        r = parseInt(right.get(), 10);
    }
    else if (right instanceof types_1.Integer && left instanceof types_1.Numc) {
        r = right.get();
        l = parseInt(left.get(), 10);
    }
    // assumption: typically no casts are required, so start checking if the types doesnt match
    if (typeof l !== typeof r) {
        if (typeof l === "string" && typeof r === "number") {
            r = r.toString();
        }
        else if (typeof l === "number" && typeof r === "string") {
            if (r === "") {
                r = 0;
            }
            else if (r.includes(".")) {
                r = parseFloat(r);
            }
            else {
                r = parseInt(r, 10);
            }
        }
    }
    /*
      console.dir(l);
      console.dir(r);
    */
    return l === r;
}
//# sourceMappingURL=eq.js.map