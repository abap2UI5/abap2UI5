"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteDatabaseClient = void 0;
const sql_js_1 = require("sql.js");
class SQLiteDatabaseClient {
    constructor(input) {
        this.name = "sqlite";
        this.sqlite = undefined;
        this.trace = input?.trace === true;
    }
    async connect(data) {
        const SQL = await (0, sql_js_1.default)();
        this.sqlite = new SQL.Database(data);
        // @ts-ignore
        if (abap?.context?.databaseConnections && abap.context.databaseConnections["DEFAULT"] === this) {
            // @ts-ignore
            abap.builtin.sy.get().dbsys?.set(this.name);
        }
    }
    async disconnect() {
        this.sqlite.close();
        this.sqlite = undefined;
    }
    async execute(sql) {
        if (typeof sql === "string") {
            if (sql === "") {
                return;
            }
            this.sqlite.run(sql);
        }
        else {
            for (const s of sql) {
                await this.execute(s);
            }
        }
    }
    export() {
        return this.sqlite?.export();
    }
    async beginTransaction() {
        return; // todo
    }
    async commit() {
        return; // todo
    }
    async rollback() {
        return; // todo
    }
    async delete(options) {
        let sql = `DELETE FROM ${options.table}`;
        if (options.where !== "") {
            sql += ` WHERE ${options.where}`;
        }
        let subrc = 0;
        let dbcnt = 0;
        try {
            if (this.trace === true) {
                console.log(sql);
            }
            this.sqlite.exec(sql);
            // https://www.sqlite.org/c3ref/changes.html
            const chg = this.sqlite.exec("SELECT changes()");
            dbcnt = chg[0]["values"][0][0];
            if (dbcnt === 0) {
                subrc = 4;
            }
        }
        catch (error) {
            subrc = 4;
        }
        return { subrc, dbcnt };
    }
    async update(options) {
        const sql = `UPDATE ${options.table} SET ${options.set.join(", ")} WHERE ${options.where}`;
        let subrc = 0;
        let dbcnt = 0;
        try {
            if (this.trace === true) {
                console.log(sql);
            }
            this.sqlite.exec(sql);
            // https://www.sqlite.org/c3ref/changes.html
            const chg = this.sqlite.exec("SELECT changes()");
            dbcnt = chg[0]["values"][0][0];
            if (dbcnt === 0) {
                subrc = 4;
            }
        }
        catch (error) {
            subrc = 4;
        }
        return { subrc, dbcnt };
    }
    async insert(options) {
        const sql = `INSERT INTO ${options.table} (${options.columns.map(c => "'" + c + "'").join(",")}) VALUES (${options.values.join(",")})`;
        let subrc = 0;
        let dbcnt = 0;
        try {
            if (this.trace === true) {
                console.log(sql);
            }
            this.sqlite.exec(sql);
            dbcnt = 1;
        }
        catch (error) {
            if (this.trace === true) {
                console.dir(error);
            }
            // eg "UNIQUE constraint failed" errors
            subrc = 4;
        }
        return { subrc, dbcnt };
    }
    // // https://www.sqlite.org/lang_select.html
    async select(options) {
        let res = undefined;
        options.select = options.select.replace(/ UP TO (\d+) ROWS(.*)/i, "$2 LIMIT $1");
        if (options.primaryKey) {
            options.select = options.select.replace(/ ORDER BY PRIMARY KEY/i, " ORDER BY " + options.primaryKey.join(", "));
        }
        else {
            options.select = options.select.replace(/ ORDER BY PRIMARY KEY/i, "");
        }
        options.select = options.select.replace(/ ASCENDING/ig, " ASC");
        options.select = options.select.replace(/ DESCENDING/ig, " DESC");
        options.select = options.select.replace(/~/g, ".");
        if (this.trace === true) {
            console.log(options.select);
        }
        try {
            res = this.sqlite.exec(options.select);
        }
        catch (error) {
            // @ts-ignore
            if (abap.Classes["CX_SY_DYNAMIC_OSQL_SEMANTICS"] !== undefined) {
                // @ts-ignore
                throw await new abap.Classes["CX_SY_DYNAMIC_OSQL_SEMANTICS"]().constructor_({ sqlmsg: error.message || "" });
            }
            throw error;
        }
        const rows = this.convert(res);
        return { rows: rows };
    }
    convert(res) {
        if (res === undefined || res.length === 0) {
            return [];
        }
        const rows = [];
        for (const sqliteRow of res[0].values) {
            const row = {};
            let i = 0;
            for (const columnName of res[0].columns) {
                row[columnName] = sqliteRow[i];
                i++;
            }
            rows.push(row);
        }
        return rows;
    }
    async openCursor(options) {
        const statement = this.sqlite.prepare(options.select, null);
        return {
            fetchNextCursor: (packageSize) => this.fetchNextCursor.bind(this)(packageSize, statement),
            closeCursor: () => this.closeCursor.bind(this)(statement),
        };
    }
    async fetchNextCursor(packageSize, statement) {
        const values = [];
        while (statement.step()) {
            values.push(statement.get());
            if (values.length === packageSize) {
                return { rows: this.convert([{ columns: statement.getColumnNames(), values }]) };
            }
        }
        return { rows: [] };
    }
    async closeCursor(statement) {
        statement.free();
    }
}
exports.SQLiteDatabaseClient = SQLiteDatabaseClient;
//# sourceMappingURL=index.js.map